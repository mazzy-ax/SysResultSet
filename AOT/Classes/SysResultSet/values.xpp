// читаем все данные из resultSet в массив
//
// у стандартного класса ResultSet есть особенности:
// 1. каждое поле можно читать только один раз. при попытке повторного чтения возникает ошибка
// 2. поля можно читать только в порядке возрастания номеров. если сначала считать поле с номером 2, а затем попытаться
//    считать поле с номером 1, то возникает ошибка.
//
// данный метод гарантирует, что чтение будет выполнено последовательно и один раз
//
// соображение по поводу "читать только по мере необходимости"
// значение может понадобиться и после next() методу getPrev().
// Поэтому все равно придется считывать все значения из resultSet до того, как завершить next()
// а если придется - то чего себе жизнь усложнять? читаем сразу все колонки.
Struct values()
{
    int n;
    int i;
    str name;
;
    if( !values )
    {
        Debug::assert(this.metaData() != null);                 // метод values должен вызываться только после удачного next

        values = new Struct();
        n = this.metaData().getColumnCount();
        for(i=1; i<=n; ++i)
        {
            name = this.metaData().getColumnName(i);            // в дальнейшем имя нужно будет получать из values или из metadata
            if( !name )
                name = strFmt("%1",i);

            // внимание! запоминаем тот тип, который был в recordSet. преобразование дат будет позже, в окончательном get
            values.add(name, SysResultSet::get(this.resultSet(), i, this.inLoop(), this.metaData().getColumnType(i), Types::AnyType));
        }
    }
    return values;
}