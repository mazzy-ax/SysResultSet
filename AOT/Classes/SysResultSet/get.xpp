// метод выполняет преобразование, необходимое для чтения из resultSet
//
// у стандартного класса ResultSet есть особенности:
// 1. каждое поле можно читать только один раз. при попытке повторного чтения возникает ошибка
// 2. поля можно читать только в порядке возрастания номеров. если сначала считать поле с номером 2, а затем попытаться
//    считать поле с номером 1, то возникает ошибка.
// Чтобы не парится с этими особенностями - используйте класс SysResultSet
//
// preferType - тип поля, куда будет помещено значение. Существенная разница проявляется в Date и UtcDateTime.
//
// метод по умолчанию возвращает тип UtcDateTime
// нужно выполнять дополнительную доводку типа для дат
// во-первых, это безопасно и не приводит к потере данных.
//            Поскольку DateTime всегда можно преобразовать к Date.
//            А вот обратное преобразование уже не восстановит потенциально потерянную информацию.
// во-вторых, к базе все равно надо обращаться по resultSet.getDateTime()
// чтобы получить именно date, стоит указать preferType = types::Date
//
// метод специально сделан статическим, чтобы его можно было использовать в старом коде, который работает со стандартным ResultSet
// хоть это и не очень хорошо с точки зрения производительности
public static AnyType get( ResultSet  resultSet,
                           int        columnIdx   = 1,
                           boolean    insideLoop  = true, // пытаемся читать значение, когда внутри цикла (next() вернул true). Или возвращаем nullValue() если находимся за циклом.
                           int        columnType  = resultSet.getMetaData().getColumnType(ColumnIdx),
                           types      preferType  = types::AnyType)
{
    AnyType ret;
    ;
    Debug::assert(resultSet != null);
    Debug::assert(columnIdx >= 1);

    // it's kind of magic... constants
    // see https://msdn.microsoft.com/en-us/library/resultsetmetadata.getcolumntype.aspx
    //
    switch( columnType )
    {
        case  0: // nvarchar = AX string
        case  8: // varchar = AX string
            if( insideLoop )
                ret = SysResultSet::convert(resultSet.getString(columnIdx), preferType);
            else
                ret = SysResultSet::getNull(Types::String, preferType);
            break;
        case  1: // int = AX int
        case  4: // tinyInt
            if( insideLoop )
                ret = SysResultSet::convert(resultSet.getInt(columnIdx), preferType);
            else
                ret = SysResultSet::getNull(Types::Integer, preferType);
            break;
        case  2: // numeric = AX real
            if( insideLoop )
                ret = SysResultSet::convert(resultSet.getReal(columnIdx), preferType);
            else
                ret = SysResultSet::getNull(Types::Real, preferType);
            break;
        case  3: // datetime OR date = AX Date and AX *utcDateTime (See NOTE)
            if( insideLoop )
                ret = SysResultSet::convert(resultSet.getDateTime(columnIdx), preferType);
            else
                ret = SysResultSet::getNull(Types::UtcDateTime, preferType);
            break;
        case 45: // uniqueidentifier = AX GUID
            if( insideLoop )
                ret = SysResultSet::convert(resultSet.getGuid(columnIdx), preferType);
            else
                ret = SysResultSet::getNull(Types::Guid, preferType);
            break;
        case 49: // bigint = AX int64
            if( insideLoop )
                ret = SysResultSet::convert(resultSet.getInt64(columnIdx), preferType);
            else
                ret = SysResultSet::getNull(Types::Int64, preferType);
            break;
        case  7: // varbinary = AX container. resultSet не умеет!
        default:
            throw error(error::wrongUseOfFunction(funcname())); // не смогли понять что за тип
    }
    return ret;
}